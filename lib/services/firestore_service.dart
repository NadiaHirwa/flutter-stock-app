import 'package:cloud_firestore/cloud_firestore.dart';

class FirestoreService {
  static final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  
  // Collections
  static const String itemsCollection = 'items';
  static const String transactionsCollection = 'transactions';

  // ========== ITEMS OPERATIONS ==========

  /// Get all items with real-time updates
  static Stream<List<Map<String, dynamic>>> getItemsStream() {
    return _firestore
        .collection(itemsCollection)
        .orderBy('name')
        .snapshots()
        .map((snapshot) => snapshot.docs.map((doc) {
              final data = doc.data();
              data['id'] = doc.id; // Add document ID
              return data;
            }).toList());
  }

  /// Get all items once (non-streaming)
  static Future<List<Map<String, dynamic>>> getItems() async {
    final snapshot = await _firestore
        .collection(itemsCollection)
        .orderBy('name')
        .get();
    return snapshot.docs.map((doc) {
      final data = doc.data();
      data['id'] = doc.id;
      return data;
    }).toList();
  }

  /// Add a new item
  static Future<String> addItem(Map<String, dynamic> itemData) async {
    // Remove 'id' if present (it's auto-generated by Firestore)
    itemData.remove('id');
    
    final docRef = await _firestore
        .collection(itemsCollection)
        .add(itemData);
    return docRef.id;
  }

  /// Update an existing item
  static Future<void> updateItem(
    String itemId,
    Map<String, dynamic> itemData,
  ) async {
    // Remove 'id' if present
    itemData.remove('id');
    
    await _firestore
        .collection(itemsCollection)
        .doc(itemId)
        .update(itemData);
  }

  /// Delete an item
  static Future<void> deleteItem(String itemId) async {
    await _firestore
        .collection(itemsCollection)
        .doc(itemId)
        .delete();
  }

  /// Get a single item by ID
  static Future<Map<String, dynamic>?> getItem(String itemId) async {
    final doc = await _firestore
        .collection(itemsCollection)
        .doc(itemId)
        .get();
    
    if (!doc.exists) return null;
    
    final data = doc.data()!;
    data['id'] = doc.id;
    return data;
  }

  // ========== TRANSACTIONS OPERATIONS ==========

  /// Get all transactions with real-time updates
  static Stream<List<Map<String, dynamic>>> getTransactionsStream() {
    return _firestore
        .collection(transactionsCollection)
        .orderBy('date', descending: true)
        .snapshots()
        .map((snapshot) => snapshot.docs.map((doc) {
              final data = doc.data();
              data['id'] = doc.id;
              // Convert Firestore Timestamp to DateTime if needed
              if (data['date'] is Timestamp) {
                data['date'] = (data['date'] as Timestamp).toDate();
              }
              return data;
            }).toList());
  }

  /// Get all transactions once (non-streaming)
  static Future<List<Map<String, dynamic>>> getTransactions() async {
    final snapshot = await _firestore
        .collection(transactionsCollection)
        .orderBy('date', descending: true)
        .get();
    
    return snapshot.docs.map((doc) {
      final data = doc.data();
      data['id'] = doc.id;
      // Convert Firestore Timestamp to DateTime if needed
      if (data['date'] is Timestamp) {
        data['date'] = (data['date'] as Timestamp).toDate();
      }
      return data;
    }).toList();
  }

  /// Add a new transaction
  static Future<String> addTransaction(Map<String, dynamic> transactionData) async {
    // Remove 'id' if present
    transactionData.remove('id');
    
    // Convert DateTime to Timestamp if needed
    if (transactionData['date'] is DateTime) {
      transactionData['date'] = Timestamp.fromDate(transactionData['date'] as DateTime);
    }
    
    // Convert itemId Reference if it's a string
    if (transactionData['itemId'] is String) {
      transactionData['itemId'] = _firestore
          .collection(itemsCollection)
          .doc(transactionData['itemId'] as String);
    }
    
    final docRef = await _firestore
        .collection(transactionsCollection)
        .add(transactionData);
    return docRef.id;
  }

  /// Update an existing transaction
  static Future<void> updateTransaction(
    String transactionId,
    Map<String, dynamic> transactionData,
  ) async {
    // Remove 'id' if present
    transactionData.remove('id');
    
    await _firestore
        .collection(transactionsCollection)
        .doc(transactionId)
        .update(transactionData);
  }

  /// Delete a transaction
  static Future<void> deleteTransaction(String transactionId) async {
    await _firestore
        .collection(transactionsCollection)
        .doc(transactionId)
        .delete();
  }

  /// Get a single transaction by ID
  static Future<Map<String, dynamic>?> getTransaction(String transactionId) async {
    final doc = await _firestore
        .collection(transactionsCollection)
        .doc(transactionId)
        .get();
    
    if (!doc.exists) return null;
    
    final data = doc.data()!;
    data['id'] = doc.id;
    // Convert Firestore Timestamp to DateTime if needed
    if (data['date'] is Timestamp) {
      data['date'] = (data['date'] as Timestamp).toDate();
    }
    return data;
  }
}

